<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>《C++ Primer》学习笔记（四）：优先级和关系运算符</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1><a id="Chttpsblogcsdnnettefuirneverarticlecategory9342309_0"></a><a href="https://blog.csdn.net/tefuirnever/article/category/9342309">专栏C++学习笔记</a></h1>
<p>《C++ Primer》学习笔记/习题答案 总目录</p>
<ul>
<li><a href="https://blog.csdn.net/TeFuirnever/article/details/100700212">https://blog.csdn.net/TeFuirnever/article/details/100700212</a></li>
</ul>
<p>——————————————————————————————————————————————————————</p>
<ul>
<li>《C++ Primer》习题参考答案：第4章 - 优先级和关系运算符</li>
</ul>
<p></p><div class="toc"><h3>文章目录</h3><ul><li><a href="#Chttpsblogcsdnnettefuirneverarticlecategory9342309_0">专栏C++学习笔记</a></li><li><a href="#_11">写在前面</a></li><li><a href="#_14">优先级和关系运算符</a></li><ul><li><a href="#1_16">1、基础</a></li><ul><ul><li><a href="#1_20">1）基础概念</a></li><li><a href="#2_43">2）优先级与结合律</a></li><li><a href="#3_62">3）求值顺序</a></li></ul></ul><li><a href="#2_84">2、算术运算符</a></li><li><a href="#3_104">3、逻辑和关系运算符</a></li><li><a href="#4_183">4、赋值运算符</a></li><li><a href="#5_245">5、递增和递减运算符</a></li><li><a href="#6_285">6、成员访问运算符</a></li><li><a href="#7_303">7、条件运算符</a></li><li><a href="#8_342">8、位运算符</a></li><li><a href="#9sizeof_373">9、sizeof运算符</a></li><li><a href="#10_398">10、逗号运算符</a></li><li><a href="#11_410">11、类型转换</a></li><ul><ul><li><a href="#1_424">1）算术转换</a></li><li><a href="#2_453">2）其他隐式类型转换</a></li><li><a href="#3_488">3）显式转换</a></li></ul></ul><li><a href="#12_521">12、运算符优先级表</a></li><li><a href="#_526">参考文章</a></li></ul></ul></div><p></p>
<h1><a id="_11"></a>写在前面</h1>
<p>哼哼，勤劳的日更博主又回来了，我的小粉丝们期待一下吧 😃<br>
<img src="https://img-blog.csdnimg.cn/2019111219263820.jpg#pic_center" alt="在这里插入图片描述"></p>
<h1><a id="_14"></a>优先级和关系运算符</h1>
<h2><a id="1_16"></a>1、基础</h2>
<p>表达式由一个或多个 <strong>运算对象（operand）</strong> 组成，对表达式求值将得到一个 <strong>结果（result）</strong>。字面值和变量是最简单的 <strong>表达式（expression）</strong>，其结果就是字面值和变量的值。把一个 <strong>运算符（operator）</strong> 和一个或多个运算对象组合起来可以生成较复杂的表达式。</p>
<h4><a id="1_20"></a>1）基础概念</h4>
<p>C++定义了 <strong>一元运算符（unary operator）</strong> 和 <strong>二元运算符（binary operator）</strong>，作用于一个运算对象的运算符是二元运算符，如取 <code>地址符( &amp; )</code> 和 <code>解引用符( * )</code>；作用于两个运算对象的运算符是二元运算符，如 <code>相等运算符( == )</code> 和 <code>乘法运算符( * )</code>。除此之外，还有一个作用于三个运算对象的 <strong>三元运算符（Ternary Operator）</strong>。函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。</p>
<blockquote>
<p>可以看到 <code>*</code> 既能作为一元运算符也能作为二元运算符。。。</p>
</blockquote>
<p>表达式求值过程中，类型转换的规则有点复杂，如：整数能转换成浮点数，浮点数也能转换成整数，但是指针不能转换成浮点数。而小整数类型（如 <code>bool</code>、<code>char</code>、<code>short</code> 等）通常会被 <strong>提升（promoted）</strong> 为较大的整数类型，主要是 <code>int</code>。</p>
<p>C++定义了运算符作用于 <strong>内置类型</strong> 和 <strong>复合类型</strong> 的运算对象时所执行的操作。当运算符作用于 <strong>类类型</strong> 的运算对象时，用户可以自定义其含义，这被称作 <strong>运算符重载（overloaded operator）</strong>，如：<code>IO</code> 库的 <code>&gt;&gt;</code> 和 <code>&lt;&lt;</code> 运算符以及 <code>string</code> 对象、<code>vector</code> 对象和迭代器使用的运算符等。</p>
<p>C++的表达式分为 <strong>右值（rvalue）</strong> 和 <strong>左值（lvalue）</strong>：</p>
<ul>
<li>当一个对象被用作右值的时候，用的是 <strong>对象的值（内容）</strong>；</li>
<li>当一个对象被用作左值的时候，用的是 <strong>对象的身份（在内存中的位置）</strong>。</li>
</ul>
<p>其中，需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）使用。</p>
<ul>
<li>赋值运算符需要一个非常量左值作为其左侧运算对象，得到的结果也仍然是一个左值；</li>
<li>取地址符作用于一个左值运算对象，返回指向该运算对象的指针，该指针是一个右值；</li>
<li>内置解引用运算符、下标运算符、迭代器解引用运算符、<code>string</code> 和 <code>vector</code> 的下标运算符都返回左值；</li>
<li>内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本返回左值，后置版本返回右值。</li>
</ul>
<p>如果 <code>decltype</code> 作用于一个求值结果是左值的表达式，会得到一个引用类型。</p>
<h4><a id="2_43"></a>2）优先级与结合律</h4>
<p><strong>复合表达式（compound expression）</strong> 指含有两个或多个运算符的表达式。运算符和运算对象合理地组合在一起，优先级与结合律决定了运算对象的组合方式，高优先级运算符先运行（乘法和除法，然后加法和减法），如果优先级相同，则其组合规则由结合律确定，从左向右顺序运行。</p>
<blockquote>
<p>python 版本的数据结构与算法也上线了，欢迎查看——<a href="https://blog.csdn.net/TeFuirnever/article/details/102944217">用Python解决数据结构与算法问题（三）：线性数据结构之栈</a>。</p>
</blockquote>
<p>括号无视优先级与结合律，表达式中括号括起来的部分被当成一个单元来求值，然后再与其他部分一起按照优先级组合。</p>
<p>举一个稍稍复杂的例子理解一下：</p>
<pre><code class="prism language-cpp"><span class="token number">6</span> <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">14</span>

<span class="token operator">&lt;=</span><span class="token operator">&gt;</span> <span class="token comment">// 等价于</span>

<span class="token comment">// 这条表达式中的括号符合默认的优先级和结合律</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span> <span class="token number">6</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">14</span>
</code></pre>
<h4><a id="3_62"></a>3）求值顺序</h4>
<p>对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。</p>
<pre><code class="prism language-c"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment">// undefined</span>
</code></pre>
<p>有4 种运算符明确规定了运算对象的求值顺序：</p>
<ul>
<li>逻辑与 ( <code>&amp;&amp;</code> ) 运算符</li>
<li>逻辑或 ( <code>||</code> ) 运算符</li>
<li>条件 ( <code>? :</code> ) 运算符</li>
<li>逗号 ( <code>,</code> ) 运算符</li>
</ul>
<p>处理复合表达式时建议遵循以下两点是有益的：</p>
<ul>
<li>不确定求值顺序时最好使用括号来强制让表达式的组合关系符合程序逻辑的要求；</li>
<li>如果表达式改变了某个运算对象的值，则在表达式的其他位置不要再使用这个运算对象。</li>
</ul>
<p>不过，第2条规则有一个重要例外，当改变运算对象的子表达式本身就是另一个子表达式的运算对象时，规则无效。例如表达式 <code>*++iter</code>，递增运算符改变了 <em>iter</em> 的值，而改变后的 <em>iter</em> 的值又是解引用运算符的运算对象。这种或者类似情况下，求值的顺序不会成为问题，因为递增运算（即改变运算对象的子表达式）必须先求值，然后才轮到解引用运算。</p>
<h2><a id="2_84"></a>2、算术运算符</h2>
<p>算术运算符（按照运算符的优先级排序）：</p>
<p><img src="https://img-blog.csdnimg.cn/20191112201917834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RlRnVpcm5ldmVy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>
上面的所有运算符都满足左结合律， 意味着当优先级相同时按照从左向右的顺序进行组合。</p>
<p>除法运算：</p>
<ul>
<li>整数相除（ <code>/</code> ）结果还是整数，即直接弃除商的小数部分；</li>
<li><strong>取余</strong> 或 <strong>取模</strong> 运算符（ <code>%</code> ）计算整数相除的余数。</li>
</ul>
<p>在除法运算中，C++语言的早期版本允许结果为负数的商向上或向下取整，C++11新标准则规定商一律向0取整（即直接去除小数部分）。</p>
<pre><code class="prism language-cpp"><span class="token number">21</span> <span class="token operator">%</span> <span class="token number">6</span><span class="token punctuation">;</span> 	<span class="token comment">/* 结果是3  */</span> 	<span class="token number">21</span> <span class="token operator">/</span> <span class="token number">6</span><span class="token punctuation">;</span> 	<span class="token comment">/* 结果是3  */</span>
<span class="token number">21</span> <span class="token operator">%</span> <span class="token number">7</span><span class="token punctuation">;</span> 	<span class="token comment">/* 结果是0  */</span> 	<span class="token number">21</span> <span class="token operator">/</span> <span class="token number">7</span><span class="token punctuation">;</span> 	<span class="token comment">/* 给果是3  */</span>
<span class="token operator">-</span><span class="token number">21</span> <span class="token operator">%</span> <span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">;</span> 	<span class="token comment">/* 结果是-5 */</span> 	<span class="token operator">-</span><span class="token number">21</span> <span class="token operator">/</span> <span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">;</span> 	<span class="token comment">/* 结果是2  */</span>
<span class="token number">21</span> <span class="token operator">%</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">;</span> 	<span class="token comment">/* 结果是1  */</span> 	<span class="token number">21</span> <span class="token operator">/</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">;</span> 	<span class="token comment">/* 结果是-4 */</span>
</code></pre>
<h2><a id="3_104"></a>3、逻辑和关系运算符</h2>
<p>关系运算符作用于算术类型和指针类型，逻辑运算符作用于任意能转换成布尔值的类型。逻辑运算符和关系运算符的返回值都是布尔类型。</p>
<p><img src="https://img-blog.csdnimg.cn/20191112205353722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RlRnVpcm5ldmVy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<hr>
<p><strong>逻辑与</strong> 运算符 <code>&amp;&amp;</code> 和 <strong>逻辑或</strong> 运算符 <code>||</code> 都是先计算左侧运算对象的值再计算右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会去计算右侧运算对象的值，这种策略称为 <strong>短路求值（short-circuit evaluation）</strong>。</p>
<ul>
<li>对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。</li>
<li>对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。</li>
</ul>
<pre><code class="prism language-cpp"><span class="token comment">// s 是对常量的引用;元素既没有被拷贝也不会被改变</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>s <span class="token operator">:</span> text<span class="token punctuation">)</span><span class="token punctuation">{</span>	<span class="token comment">// 对于text 的每个元素</span>
	cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">;</span> 				<span class="token comment">// 输出当前元素</span>
	<span class="token comment">// 遇到空字符亭或者以句号结束的字符串进行换行</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> s<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">)</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> 		<span class="token comment">// 否则用空格隔开</span>
<span class="token punctuation">}</span>
</code></pre>
<p><code>if</code> 语句的条件部分首先检查 <code>s</code> 是否是一个空 <code>string</code>，如果是，则不论右侧如何都换行；只有当 <code>string</code> 对象非空时才求第二个运算对象的值，即是否是以句号结束。</p>
<hr>
<p><strong>逻辑非</strong> 运算符 <code>!</code> 将运算对象的值取反后返回。</p>
<pre><code class="prism language-cpp"><span class="token comment">// 输出vec的首元素(如果有的话)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vec<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	cout <span class="token operator">&lt;&lt;</span> vec<span class="token punctuation">[</span>O<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>
<hr>
<p>关系运算符比较运算对象的大小关系并返回布尔值，关系运算符都满足左结合律。</p>
<pre><code class="prism language-cpp"><span class="token comment">// 哎哟!这个条件居然拿i&lt;j的布尔值结果和k比较</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span> i <span class="token operator">&lt;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> 	<span class="token comment">// 若k大于1则为真</span>
<span class="token comment">// 正确:当i小于j并且j小于k时条件为真</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">/* ... */</span>
<span class="token punctuation">}</span>
</code></pre>
<hr>
<p>测试真值，最直接的方法就是将其作为 <code>if</code> 语句的条件。</p>
<pre><code class="prism language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">/* ... */</span>
<span class="token punctuation">}</span> <span class="token comment">// 如果val是任意的非0值，条件为真</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>val<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">/* ... */</span>
<span class="token punctuation">}</span> <span class="token comment">// 如果val是0，条件为真</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">/* ... */</span>
<span class="token punctuation">}</span> <span class="token comment">// 只有当val等于true时条件才为真!</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">/* ... */</span>
<span class="token punctuation">}</span> <span class="token comment">// 只有当val等于1时条件才为真!</span>
</code></pre>
<blockquote>
<p>进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值 <code>true</code> 和 <code>false</code> 作为运算对象。</p>
</blockquote>
<h2><a id="4_183"></a>4、赋值运算符</h2>
<p>赋值运算符 <code>=</code> 的左侧运算对象必须是一个 <strong>可修改</strong> 的 <strong>左值</strong>。</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">// 初始化而非赋值</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> i<span class="token punctuation">;</span>			<span class="token comment">// 初始化而非赋值</span>

<span class="token number">1024</span> <span class="token operator">=</span> k <span class="token punctuation">;</span>					<span class="token comment">// 错误:字面值是右值</span>
i <span class="token operator">+</span> j <span class="token operator">=</span> k <span class="token punctuation">;</span>					<span class="token comment">// 错误:算术表达式是右值</span>
ci <span class="token operator">=</span> k<span class="token punctuation">;</span>						<span class="token comment">// 错误:ci是常量(不可修改的)左值</span>
</code></pre>
<p>C++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象。</p>
<pre><code class="prism language-c">k <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>						<span class="token comment">// 错误:窄化转换</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vi<span class="token punctuation">;</span>     			<span class="token comment">// 初始为空</span>
vi <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 	<span class="token comment">// vi现在含有10个元素了，值从0到9</span>
</code></pre>
<p>赋值运算符满足右结合律。</p>
<pre><code class="prism language-c"><span class="token keyword">int</span> ival<span class="token punctuation">,</span> jval<span class="token punctuation">;</span>
ival <span class="token operator">=</span> jval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 正确:都被赋值为0</span>

<span class="token keyword">int</span> ival<span class="token punctuation">,</span> <span class="token operator">*</span>pval<span class="token punctuation">;</span>	<span class="token comment">// ival的类型是int;pval是指向int的指针</span>
ival <span class="token operator">=</span> pval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">// 错误: 不能把指针的值赋给int</span>

string s1<span class="token punctuation">,</span> s2<span class="token punctuation">;</span>
s1 <span class="token operator">=</span> s2 <span class="token operator">=</span> <span class="token string">"OK"</span><span class="token punctuation">;</span>		<span class="token comment">// 字符串字面值"OK"转换成string对象</span>
</code></pre>
<p>因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。</p>
<pre><code class="prism language-cpp"><span class="token comment">// 这是一种形式烦琐、容易出错的写法</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">get_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 得到第一个值</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">42</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">// 其他处理......</span>
	i <span class="token operator">=</span> <span class="token function">get_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 得到剩下的值</span>
<span class="token punctuation">}</span>

<span class="token comment">// 更好的写法:条件部分表达得更加清晰</span>
<span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token function">get_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">42</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">// 其他处理......</span>
<span class="token punctuation">}</span>
</code></pre>
<p>不要混淆相等运算符 <code>==</code> 和赋值运算符 <code>=</code>。</p>
<pre><code class="prism language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> j<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span>
</code></pre>
<p>复合赋值运算符包括 <code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>（算术运算符）；<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&amp;=</code>、<code>^=</code> 和 <code>|=</code>（位运算符）。任意一种复合运算都完全等价于 <em>a = a op b</em>。</p>
<h2><a id="5_245"></a>5、递增和递减运算符</h2>
<p>递增（ <code>++</code> ）和递减（ <code>--</code> ）运算符是为对象加1或减1的简洁书写形式。这两个运算符还可应用于迭代器，因为很多迭代器本身不支持算术运算。</p>
<p>递增和递减运算符分为前置版本和后置版本：</p>
<ul>
<li>前置版本：首先将运算对象加1（或减1），然后将改变后的对象作为求值结果。</li>
<li>后置版本：也会将运算对象加1（或减1），但求值结果是运算对象改变前的值的副本。</li>
</ul>
<pre><code class="prism language-c"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">;</span>
j <span class="token operator">=</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>    <span class="token comment">// j = 1, i = 1: 前置版本得到递增之后的值</span>
j <span class="token operator">=</span> i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// j = 1, i = 2: 后置版本得到递增之前的值</span>
</code></pre>
<p>除非必须，否则不应该使用递增或递减运算符的后置版本。因为后置版本需要将原始值存储下来以便于返回修改前的内容，如果我们不需要这个值，那么后置版本的操作就是一种浪费。</p>
<blockquote>
<p>对于整数和指针类型来说，编译器可能对这种额外的工作进行一定的优化；但是对于相对复杂的迭代器类型，这种额外的工作就消耗巨大了。建议养成使用前置版本的习惯，这样不仅不需要担心性能的问题， 而且更重要的是写出的代码会更符合编程的初衷。</p>
</blockquote>
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> pbeg <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出元素直至遇到第一个负值为止</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>pbeg <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>beg <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token comment">// 输出当前值并将pbeg向前移动一个元素</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>pbeg<span class="token operator">++</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre>
<p>对于刚接触C++和C的程序员来说，<code>*pbeg++</code> 不太容易理解，但其实这种写法非常普遍，所以一定要理解其含义。<strong>后置递增运算符的优先级高于解引用运算符</strong>，因此 <code>*pbeg++</code> 等价于 <code>*(pbeg++)</code>。<code>pbeg++</code> 把 <code>pbeg</code> 的值加1， 然后返回 <code>pbeg</code> 的初始值的副本作为其求值结果，此时解引用运算符的运算对象是 <code>pbeg</code> 未增加之前的值。最终，这条语句输出 <code>pbeg</code> 开始时指向的那个元素，并将指针向前移动一个位置。</p>
<blockquote>
<p>如果返回的是加1之后的值，解引用该值将产生错误的结果。不但无法输出第一个元素，而且更糟糕的是如果序列中没有负值，程序将可能试图解引用一个根本不存在的元素。</p>
</blockquote>
<p>在某些语句中混用解引用和递增运算符可以使程序更简洁！！！</p>
<pre><code class="prism language-c">cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>iter<span class="token operator">++</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

<span class="token comment">// cout &lt;&lt; *iter &lt;&lt; endl;</span>
<span class="token comment">// ++iter;</span>
</code></pre>
<h2><a id="6_285"></a>6、成员访问运算符</h2>
<p>点运算符 <code>.</code> 和箭头运算符 <code>-&gt;</code> 都可以用来访问成员，其中，点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式 <code>ptr-&gt;mem</code> 等价于 <code>(*ptr).mem</code>。</p>
<pre><code class="prism language-c">string s1 <span class="token operator">=</span> <span class="token string">"a string"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>s1<span class="token punctuation">;</span>
<span class="token keyword">auto</span> n <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 运行string对象s1的size成员</span>
n <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 运行p所指对象的size成员</span>
n <span class="token operator">=</span> p<span class="token operator">-&gt;</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 等价于(*p).size()</span>
</code></pre>
<p>因为解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号。如果没如括号，代码的含义就大不相同了：</p>
<pre><code class="prism language-cpp"><span class="token comment">//运行p的size成员，然后解引用size的结果</span>
<span class="token operator">*</span>p<span class="token punctuation">.</span>size <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误：p是一个指针，它没有名为size的成员</span>
</code></pre>
<h2><a id="7_303"></a>7、条件运算符</h2>
<p>条件运算符（? :）的使用形式如下：</p>
<pre><code class="prism language-c">cond <span class="token operator">?</span> expr1 <span class="token punctuation">:</span> expr2<span class="token punctuation">;</span>
</code></pre>
<p>其中 <em>cond</em> 是判断条件的表达式，而 <em>expr1</em> 和 <em>expr2</em> 是两个类型相同或可能转换为某个公共类型的表达式。先求 <em>cond</em> 的值，如果 <em>cond</em> 为真则对 <em>expr1</em> 求值并返回该值，否则对 <em>expr2</em> 求值并返回该值。</p>
<pre><code class="prism language-cpp">string finalgrade <span class="token operator">=</span> <span class="token punctuation">(</span>grade <span class="token operator">&lt;</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"fail"</span> <span class="token operator">:</span> <span class="token string">"pass"</span><span class="token punctuation">;</span>
</code></pre>
<p>只有当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果才是左值，否则运算的结果就是右值。</p>
<p>条件运算符可以嵌套，但是考虑到代码的可读性，运算的嵌套层数最好不要超过两到三层。</p>
<pre><code class="prism language-cpp">finalgrade <span class="token operator">=</span> <span class="token punctuation">(</span>grade <span class="token operator">&gt;</span> <span class="token number">90</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"high pass"</span>
							<span class="token operator">:</span> <span class="token punctuation">(</span>grade <span class="token operator">&lt;</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"fail"</span> <span class="token operator">:</span> <span class="token string">"pass"</span><span class="token punctuation">;</span>
</code></pre>
<p>条件运算符的优先级非常低，因此当一个长表达式中嵌套了条件运算子表达式时，通常需要在它两端加上括号。</p>
<pre><code class="prism language-cpp">cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>grade <span class="token operator">&lt;</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"fail"</span> <span class="token operator">:</span> <span class="token string">"pass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">// 输出pass或者fail</span>

cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>grade <span class="token operator">&lt;</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"fail"</span> <span class="token operator">:</span> <span class="token string">"pass"</span><span class="token punctuation">;</span> 	<span class="token comment">// 输出1或者0</span>
<span class="token comment">// 等价于&lt;=&gt;</span>
<span class="token comment">// cout &lt;&lt; (grade &lt; 60); 					// 输出1或者0</span>
<span class="token comment">// cout ? "fail" : "pass"; 					// 根据cout的值是true还是false产生对应的字面值</span>

cout <span class="token operator">&lt;&lt;</span> grade <span class="token operator">&lt;</span> <span class="token number">60</span> <span class="token operator">?</span> <span class="token string">"fail"</span> <span class="token operator">:</span> <span class="token string">"pass"</span><span class="token punctuation">;</span> 		<span class="token comment">// 错误:试图比较cout和60</span>
<span class="token comment">// 等价于&lt;=&gt;</span>
<span class="token comment">// cout &lt;&lt; grade; 							// 小于运算符的优先级低于移位运算符，所以先输出grade</span>
<span class="token comment">// cout &lt; 60 ? "fail" : "pass"; 			// 然后比较cout和60</span>
</code></pre>
<h2><a id="8_342"></a>8、位运算符</h2>
<p>位运算符（左结合律）：<br>
<img src="https://img-blog.csdnimg.cn/20191113095826617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RlRnVpcm5ldmVy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>
在位运算中符号位如何处理并没有明确的规定，所以强烈建议仅将位运算符用于无符号类型的处理。</p>
<p>左移运算符 <code>&lt;&lt;</code> 在运算对象右侧插入值为0的二进制位，右移运算符 <code>&gt;&gt;</code> 的行为依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在其左侧插入值为0的二进制位；如果是带符号类型，在其左侧插入符号位的副本或者值为0的二进制位，如何选择视具体环境而定。<br>
<img src="https://img-blog.csdnimg.cn/20191113100117866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RlRnVpcm5ldmVy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<hr>
<p>位求反运算符（ <code>~</code> ）将运算对象逐位求反而生成一个新值，将1置为0、将0置为1。<br>
<img src="https://img-blog.csdnimg.cn/20191113100300488.png#pic_center" alt="在这里插入图片描述"><br>
char 类型的运算对象首先提升成 int 类型，提升时运算对象原来的位保持不变， 往 <strong>高位（high order position）</strong> 添0即可。</p>
<hr>
<p>与（ <code>&amp;</code> ）、或( <code>|</code> )、异或（ <code>^</code> ）运算符在两个运算对象上逐位执行相应的逻辑操作。<br>
<img src="https://img-blog.csdnimg.cn/20191113100703510.png#pic_center" alt="在这里插入图片描述"><br>
与和或都是比较常见的了，就不说了，对于 <strong>位异或运算符（ <code>^</code> ）</strong> 来说，如果两个运算对象的对应位置元素不同则运算结果中该位为1，否则为0。</p>
<p>移位运算符的优先级不高不低，介于中间：比算术运算符的优先级低，但比关系运算符、赋值运算符和条件运算符的优先级高。</p>
<pre><code class="prism language-cpp">cout <span class="token operator">&lt;&lt;</span> <span class="token number">42</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span> 	<span class="token comment">// 正确：+的优先级更高，因此输出求和结果</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">&lt;</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">// 正确：括号使运算对象按照我们的期望组合在一起，输出1</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token number">10</span> <span class="token operator">&lt;</span> <span class="token number">42</span><span class="token punctuation">;</span> 	<span class="token comment">// 错误：试图比较cout和42!</span>
<span class="token comment">// 等价于&lt;=&gt;</span>
<span class="token comment">// (cout &lt;&lt; 10) &lt; 42;</span>
</code></pre>
<h2><a id="9sizeof_373"></a>9、sizeof运算符</h2>
<p><code>sizeof</code> 运算符返回一个表达式或一个类型名字所占的字节数，返回值是 <code>size_t</code> 类型。</p>
<pre><code class="prism language-cpp">Sales_data data<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token keyword">sizeof</span><span class="token punctuation">(</span>Sales_data<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">// 存储Sales_data类型的对象所占的空间大小</span>
<span class="token keyword">sizeof</span> data<span class="token punctuation">;</span>					<span class="token comment">// data的类型的大小，即sizeof(Sales_data)</span>
<span class="token keyword">sizeof</span> p<span class="token punctuation">;</span>						<span class="token comment">// 指针所占的空间大小</span>
<span class="token keyword">sizeof</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>						<span class="token comment">// p所指类型的空间大小，即sizeof(Sales_data)</span>
<span class="token keyword">sizeof</span> data<span class="token punctuation">.</span>revenue<span class="token punctuation">;</span> 			<span class="token comment">// Sales_data的revenue成员对应类型的大小</span>
<span class="token keyword">sizeof</span> Sales_data<span class="token operator">::</span>revenue<span class="token punctuation">;</span> 	<span class="token comment">// 另一种获取revenue大小的方式</span>
</code></pre>
<p>在 <code>sizeof</code> 的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用。</p>
<p><code>sizeof</code> 运算符的结果部分依赖于其作用的类型：</p>
<ul>
<li>对 <code>char</code> 或者类型为 <code>char</code> 的表达式执行 <code>sizeof</code> 运算，返回值为1。</li>
<li>对引用类型执行 <code>sizeof</code> 运算得到被引用对象所占空间的大小。</li>
<li>对指针执行 <code>sizeof</code> 运算得到指针本身所占空间的大小。</li>
<li>对解引用指针执行 <code>sizeof</code> 运算得到指针指向的对象所占空间的大小，指针不需要有效。</li>
<li>对数组执行 <code>sizeof</code> 运算得到整个数组所占空间的大小。</li>
<li>对 <code>string</code> 或 <code>vector</code> 对象执行 <code>sizeof</code> 运算只返回该类型固定部分的大小，不会计算对象中元素所占空间的大小。</li>
</ul>
<h2><a id="10_398"></a>10、逗号运算符</h2>
<p>逗号运算符 <code>,</code> 含有两个运算对象，按照从左向右的顺序依次求值，最后返回右侧表达式的值。逗号运算符经常用在 <code>for</code> 循环中。</p>
<pre><code class="prism language-c">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">:</span><span class="token punctuation">:</span>size_type cnt <span class="token operator">=</span> ivec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将把从size到1的值赋给ivec的元素</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">:</span><span class="token punctuation">:</span>size_type ix <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
				ix <span class="token operator">!=</span> ivec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>ix<span class="token punctuation">,</span> <span class="token operator">--</span>cnt<span class="token punctuation">)</span>
    ivec<span class="token punctuation">[</span>ix<span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">;</span>
</code></pre>
<h2><a id="11_410"></a>11、类型转换</h2>
<p>在C++语言中，某些类型之间有关联。如果两种类型有关联， 那么当程序需要其中一种类型的运算对象时，可以用另一种关联类型的对象或值来替代。换句话说，如果两种类型可以 <strong>相互转换（conversion）</strong>，那么它们就是关联的。</p>
<p>无须程序员介入，会自动执行的类型转换叫做 <strong>隐式转换（implicit conversions）</strong>，可以尽可能地避免损失精度。</p>
<p>在下面这些情况下， 编译器会自动地转换运算对象的类型：</p>
<ul>
<li>在大多数表达式中，比 <code>int</code> 类型小的整型值首先提升为较大的整数类型。</li>
<li>在条件中，非布尔值转换成布尔类型。</li>
<li>在初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。</li>
<li>如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。</li>
<li>函数调用时也会发生类型转换。</li>
</ul>
<h4><a id="1_424"></a>1）算术转换</h4>
<p>把一种算术类型转换成另一种算术类型叫做 <strong>算术转换（arithmetic conversion）</strong>，其中运算符的运算对象将被转换成最宽的类型。</p>
<p><strong>整型提升（integral promotions）</strong> 负责把小整数类型转换成较大的整数类型。</p>
<p>如果某个运算符的运算对象类型不一致， 这些运算对象将转换成同一种类型。但是如果某个运算对象的类型是无符号类型，那么转换的结果就要依赖于机器中各个整数类型的相对大小了。</p>
<p>要想理解算术转换， 办法之一就是研究大量的例子:</p>
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> flag<span class="token punctuation">;</span> 		<span class="token keyword">char</span> cval<span class="token punctuation">;</span>
<span class="token keyword">short</span> sval<span class="token punctuation">;</span> 	unsignedshort usval<span class="token punctuation">;</span>
<span class="token keyword">int</span> ival<span class="token punctuation">;</span> 		<span class="token keyword">unsigned</span> <span class="token keyword">int</span> uival<span class="token punctuation">;</span>
<span class="token keyword">long</span> lval<span class="token punctuation">;</span> 		<span class="token keyword">unsigned</span> <span class="token keyword">long</span> ulval<span class="token punctuation">;</span>
<span class="token keyword">float</span> fval<span class="token punctuation">;</span> 	<span class="token keyword">double</span> dval<span class="token punctuation">;</span>

<span class="token number">3.14159L</span> <span class="token operator">+</span> <span class="token string">'a'</span><span class="token punctuation">;</span>	<span class="token comment">// 'a'提升成int，然后该int值转换成long double</span>
dval <span class="token operator">+</span> ival<span class="token punctuation">;</span> 	<span class="token comment">// ival转换成double</span>
dval <span class="token operator">+</span> fval<span class="token punctuation">;</span>	<span class="token comment">// fval转换成double</span>
ival <span class="token operator">=</span> dval<span class="token punctuation">;</span>	<span class="token comment">// dval转换成(切除小数部分后)int</span>
flag <span class="token operator">=</span> dval<span class="token punctuation">;</span>	<span class="token comment">// 如果dval是0，则flag是false，否则flag是true</span>
cval <span class="token operator">+</span> fval<span class="token punctuation">;</span>	<span class="token comment">// cval提升成int，然后该int值转换成float</span>
sval <span class="token operator">+</span> cval<span class="token punctuation">;</span>	<span class="token comment">// sval和cval都提升成int</span>
cval <span class="token operator">+</span> lval<span class="token punctuation">;</span>	<span class="token comment">// cval转换成long</span>
ival <span class="token operator">+</span> ulval<span class="token punctuation">;</span>	<span class="token comment">// ival转换成unsigned long</span>
usval <span class="token operator">+</span> ival<span class="token punctuation">;</span>	<span class="token comment">// 根据unsigned short和int所占空间的大小进行提升</span>
uival <span class="token operator">+</span> lval<span class="token punctuation">;</span>	<span class="token comment">// 根据unsigned int和long所占空间的大小进行转换</span>
</code></pre>
<h4><a id="2_453"></a>2）其他隐式类型转换</h4>
<ul>
<li>数组转换成指针：在大多数表达式中，数组名字自动转换成指向数组首元素的指针。</li>
</ul>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 	<span class="token comment">// 含有10个整数的数组</span>
<span class="token keyword">int</span><span class="token operator">*</span> ip <span class="token operator">=</span> ia<span class="token punctuation">;</span>	<span class="token comment">// ia转换成指向放组首元素的指针</span>
</code></pre>
<ul>
<li>
<p>指针的转换：常量整数值0或字面值 <code>nullptr</code> 能转换成任意指针类型；指向任意非常量的指针能转换成 <code>void*</code>；指向任意对象的指针能转换成 <code>const void*</code>。</p>
</li>
<li>
<p>转换成布尔类型：任意一种算术类型或指针类型都能转换成布尔类型。如果指针或算术类型的值为0，转换结果是 <code>false</code>，否则是 <code>true</code>。</p>
</li>
</ul>
<pre><code class="prism language-cpp"><span class="token keyword">char</span> <span class="token operator">*</span>cp <span class="token operator">=</span> <span class="token function">get_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>cp<span class="token punctuation">)</span> <span class="token comment">/* ... */</span> 		<span class="token comment">// 如果指针cp不是0，条件为真</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>cp<span class="token punctuation">)</span> <span class="token comment">/* ... */</span> 	<span class="token comment">// 如果*cp不是空字符，条件为真</span>
</code></pre>
<ul>
<li>转换成常量：允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。</li>
</ul>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span>	<span class="token comment">// 非常量转换成const int的引用</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>	<span class="token comment">// 非常量的地址转换成const的地址</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> j<span class="token punctuation">,</span> <span class="token operator">*</span>q <span class="token operator">=</span> p<span class="token punctuation">;</span>	<span class="token comment">// 错误:不允许const转换成非常量</span>
</code></pre>
<ul>
<li>类类型定义的转换：类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换。</li>
</ul>
<pre><code class="prism language-cpp">string s<span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token string">"a value"</span><span class="token punctuation">;</span>	<span class="token comment">// 字符串字而位转换成string类型</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> s<span class="token punctuation">)</span>			<span class="token comment">// while的条件部分把cin转换成布尔值</span>
</code></pre>
<h4><a id="3_488"></a>3）显式转换</h4>
<p><strong>显式类型转换</strong> 也叫做 <strong>强制类型转换（cast）</strong>。</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
<span class="token keyword">double</span> slope <span class="token operator">=</span> i<span class="token operator">/</span>j<span class="token punctuation">;</span>
</code></pre>
<p>虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。<strong>建议尽量避免强制类型转换。</strong></p>
<p><strong>命名的强制类型转换（named cast）</strong> 形式如下：</p>
<pre><code class="prism language-c">cast<span class="token operator">-</span>name<span class="token operator">&lt;</span>type<span class="token operator">&gt;</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>其中 <em>type</em> 是转换的目标类型，<em>expression</em> 是要转换的值。如果 <em>type</em> 是引用类型，则转换结果是左值。<em>cast-name</em> 是 <code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code> 和 <code>reinterpret_cast</code> 中的一种，用来指定转换的方式。</p>
<ul>
<li><code>dynamic_cast</code> 支持运行时类型识别。</li>
<li>任何具有明确定义的类型转换，只要不包含底层 <code>const</code>，都能使用 <code>static_cast</code>。当需要把一个较大的算术类型赋值给较小的类型时，<code>static cast</code> 非常有用。<code>static cast</code> 对于编译器无法自动执行的类型转换也非常有用。</li>
<li><code>const_cast</code> 只能改变运算对象的底层 <code>const</code>，同时也只有 <code>const_cast</code> 能改变表达式的常量属性。<code>const_cast</code> 常常用于函数重载。</li>
<li><code>reinterpret_cast</code> 通常为运算对象的位模式提供底层上的重新解释。<code>reinterpret_cast</code> 本质上依赖于机器。要想安全地使用<code>reinterpret_cast</code> 必须对涉及的类型和编译器实现转换的过程都非常了解。</li>
</ul>
<p>早期版本的C++语言中，显式类型转换包含两种形式：</p>
<pre><code class="prism language-c">type <span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 函数形式的强制类型转换</span>
<span class="token punctuation">(</span>type<span class="token punctuation">)</span> expression<span class="token punctuation">;</span>    <span class="token comment">// C语言风格的强制类型转换</span>
</code></pre>
<p>与命名的强制类型转换相比，旧式的强制类型转换从表现形式上来说不那么清晰明了了，容易被看漏，所以一旦转换过程出现问题，追踪起来也更加困难。</p>
<h2><a id="12_521"></a>12、运算符优先级表</h2>
<p><img src="https://img-blog.csdnimg.cn/20191113094025172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RlRnVpcm5ldmVy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/20191113094105291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RlRnVpcm5ldmVy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/20191113094149252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RlRnVpcm5ldmVy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2><a id="_526"></a>参考文章</h2>
<ul>
<li>《C++ Primer》</li>
</ul>
</div>
</body>

</html>
